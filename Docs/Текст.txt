1 СЛАЙД - Драсьте, сегодня я буду представлять курсовой проект 
по теме "Разработка и тестирование приложения «Шифратор сообщений»".

2 СЛАЙД - Цель курсового проекта заключается в проведении тестирования функций приложения шифровки сообщений.

3 СЛАЙД - Соответственно, задачами будут являться:
Проведение анализа конкурентов;
Ознакомление с требованиями по продукту;
Просмотр кода тестируемых функций;
Описание тестовых случаев;
Определение входных данных для тестируемых функций;
И, наконец, проведение тестирования реализованных функций.

4 СЛАЙД - В качестве инструментов тестирования приложения был использован фреймворк MSTest и паттерн тестирования Arrange - Act - Assert. 
MSTest был выбран по причине наличия всех необходимых для тестирования классов, верифицирующих результат теста. 
Более того, он по умолчанию используется в MS Visual Studio с 2005 года, если не ошибаюсь.
Паттерн тестирования Arrange - Act - Assert был выбран преимущественно из-за повышения читабельности кода тестовых методов.

5 СЛАЙД - Далее представлен набор тестовых сценариев. На этом слайде отображены тестовые сценарии для шифровки и дешифровки сообщений первым способом, ---ожидание---

6 СЛАЙД - то же, но для шифровки и дешифровки сообщений вторым способом, ---ожидание---

7 СЛАЙД - то же, для третьего способа, ---ожидание---

8 СЛАЙД - и для четвертого. ---ожидание---

9 СЛАЙД - Здесь и далее размещен код основныех модульных тестов, ниже - результат их
 выполнения. Это - тестирование метода шифровки первым способом, ---ожидание---

10 СЛАЙД - для шифровки вторым способом, ---ожидание---

11 СЛАЙД - и шифровка третьим способом. ---ожидание---

12 СЛАЙД - Здесь - тестирование метода дешифровки сообщений, 
зашифрованных первым способом, ---ожидание---

13 СЛАЙД - то же, для второго способа, ---ожидание---

14 СЛАЙД - и для третьего. ---ожидание---

15 СЛАЙД - По итогу написания данного курсового проекта был разработан конечный
 продукт и были протестированы такие его функции, как:
Шифровка сообщений четырьмя способами и дешифровка 
сообшений, зашифрованных соответствующими способами.

Были написаны модульные тесты для всех методов, возвращающих значения (см. приложение А, микрочелы).
Таким образом можно сделать вывод о достижении поставленных задачах.

16 СЛАЙД (final) - На этом у меня все, благодарю за внимание и слушаю ваши вопросы.




















Верификация — проверка соответствия приложения прописанным требованиям.

Валидация — проверка соответствия приложения всем остальным (подразумеваемым) требованиям.

Ну, и чо?

Когда я только выполнял чужие кейсы, это всё было ненужным и абстрактным лайном.

Когда я сам проектировал тесты, да ещё и для какой-то финансовой аппликухи — приходилось знать/понимать точно, какие тесты покрывают прописанные требования (верификационные), а какие тесты покрывают НЕпрописанные требования (валидационные) и соответственно их разделять по разным сборникам тестов. И это всё стало осязаемым и важным.


Верификационные тесты, с отсылками к требованиям, программисты принимали, не каркая.

А валидационные запросто отклоняли, бо «тестируется сценарий, которые не предусмотрен требованиями».

Типичный пример: продвигаемся на каком-нибудь государственном портале по сценарию оформления заказа госуслуги (или на сайте подбора авиабилетов по сценарию заказа авиабилета, не суть). На каждом шаге подтягиваются данные из разных источников, которые передаются между экранами, все дела.
Если в этот момент юзер решит вернуться на шаг назад — он должен передвигаться между экранами только через JS-кнопки «back» и «forward» в приложении (почти каждый современный сайт — приложение). Так написано в требованиях, так реализовано программистами.
А если нажать на кнопку [Back] в браузере — всё поломалось.
Это очевидно для пользователя? Нет.
Пользователь может нажать на кнопку [Back] в браузере? Может.
И получит белый экран, и все данные пропали? Получит. Вот скриншот. Вот видео. Давайте чинить!

Ответ: Declined (out of requirements).